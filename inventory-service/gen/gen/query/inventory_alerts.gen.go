// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/people257/poor-guy-shop/inventory-service/gen/gen/model"
)

func newInventoryAlert(db *gorm.DB, opts ...gen.DOOption) inventoryAlert {
	_inventoryAlert := inventoryAlert{}

	_inventoryAlert.inventoryAlertDo.UseDB(db, opts...)
	_inventoryAlert.inventoryAlertDo.UseModel(&model.InventoryAlert{})

	tableName := _inventoryAlert.inventoryAlertDo.TableName()
	_inventoryAlert.ALL = field.NewAsterisk(tableName)
	_inventoryAlert.ID = field.NewString(tableName, "id")
	_inventoryAlert.SkuID = field.NewString(tableName, "sku_id")
	_inventoryAlert.AlertType = field.NewString(tableName, "alert_type")
	_inventoryAlert.CurrentQuantity = field.NewInt32(tableName, "current_quantity")
	_inventoryAlert.AlertQuantity = field.NewInt32(tableName, "alert_quantity")
	_inventoryAlert.Message = field.NewString(tableName, "message")
	_inventoryAlert.IsResolved = field.NewBool(tableName, "is_resolved")
	_inventoryAlert.ResolvedAt = field.NewTime(tableName, "resolved_at")
	_inventoryAlert.ResolvedBy = field.NewString(tableName, "resolved_by")
	_inventoryAlert.CreatedAt = field.NewTime(tableName, "created_at")

	_inventoryAlert.fillFieldMap()

	return _inventoryAlert
}

type inventoryAlert struct {
	inventoryAlertDo inventoryAlertDo

	ALL             field.Asterisk
	ID              field.String // 主键ID
	SkuID           field.String // SKU ID（UUID类型）
	AlertType       field.String // 告警类型：low_stock(库存不足)/out_of_stock(库存售罄)
	CurrentQuantity field.Int32  // 触发告警时的当前库存数量
	AlertQuantity   field.Int32  // 告警阈值
	Message         field.String // 告警消息内容
	IsResolved      field.Bool   // 是否已解决告警
	ResolvedAt      field.Time   // 告警解决时间
	ResolvedBy      field.String // 解决告警的操作人ID（UUID类型）
	CreatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (i inventoryAlert) Table(newTableName string) *inventoryAlert {
	i.inventoryAlertDo.UseTable(newTableName)
	return i.updateTableName(newTableName)
}

func (i inventoryAlert) As(alias string) *inventoryAlert {
	i.inventoryAlertDo.DO = *(i.inventoryAlertDo.As(alias).(*gen.DO))
	return i.updateTableName(alias)
}

func (i *inventoryAlert) updateTableName(table string) *inventoryAlert {
	i.ALL = field.NewAsterisk(table)
	i.ID = field.NewString(table, "id")
	i.SkuID = field.NewString(table, "sku_id")
	i.AlertType = field.NewString(table, "alert_type")
	i.CurrentQuantity = field.NewInt32(table, "current_quantity")
	i.AlertQuantity = field.NewInt32(table, "alert_quantity")
	i.Message = field.NewString(table, "message")
	i.IsResolved = field.NewBool(table, "is_resolved")
	i.ResolvedAt = field.NewTime(table, "resolved_at")
	i.ResolvedBy = field.NewString(table, "resolved_by")
	i.CreatedAt = field.NewTime(table, "created_at")

	i.fillFieldMap()

	return i
}

func (i *inventoryAlert) WithContext(ctx context.Context) IInventoryAlertDo {
	return i.inventoryAlertDo.WithContext(ctx)
}

func (i inventoryAlert) TableName() string { return i.inventoryAlertDo.TableName() }

func (i inventoryAlert) Alias() string { return i.inventoryAlertDo.Alias() }

func (i inventoryAlert) Columns(cols ...field.Expr) gen.Columns {
	return i.inventoryAlertDo.Columns(cols...)
}

func (i *inventoryAlert) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := i.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (i *inventoryAlert) fillFieldMap() {
	i.fieldMap = make(map[string]field.Expr, 10)
	i.fieldMap["id"] = i.ID
	i.fieldMap["sku_id"] = i.SkuID
	i.fieldMap["alert_type"] = i.AlertType
	i.fieldMap["current_quantity"] = i.CurrentQuantity
	i.fieldMap["alert_quantity"] = i.AlertQuantity
	i.fieldMap["message"] = i.Message
	i.fieldMap["is_resolved"] = i.IsResolved
	i.fieldMap["resolved_at"] = i.ResolvedAt
	i.fieldMap["resolved_by"] = i.ResolvedBy
	i.fieldMap["created_at"] = i.CreatedAt
}

func (i inventoryAlert) clone(db *gorm.DB) inventoryAlert {
	i.inventoryAlertDo.ReplaceConnPool(db.Statement.ConnPool)
	return i
}

func (i inventoryAlert) replaceDB(db *gorm.DB) inventoryAlert {
	i.inventoryAlertDo.ReplaceDB(db)
	return i
}

type inventoryAlertDo struct{ gen.DO }

type IInventoryAlertDo interface {
	gen.SubQuery
	Debug() IInventoryAlertDo
	WithContext(ctx context.Context) IInventoryAlertDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IInventoryAlertDo
	WriteDB() IInventoryAlertDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IInventoryAlertDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IInventoryAlertDo
	Not(conds ...gen.Condition) IInventoryAlertDo
	Or(conds ...gen.Condition) IInventoryAlertDo
	Select(conds ...field.Expr) IInventoryAlertDo
	Where(conds ...gen.Condition) IInventoryAlertDo
	Order(conds ...field.Expr) IInventoryAlertDo
	Distinct(cols ...field.Expr) IInventoryAlertDo
	Omit(cols ...field.Expr) IInventoryAlertDo
	Join(table schema.Tabler, on ...field.Expr) IInventoryAlertDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IInventoryAlertDo
	RightJoin(table schema.Tabler, on ...field.Expr) IInventoryAlertDo
	Group(cols ...field.Expr) IInventoryAlertDo
	Having(conds ...gen.Condition) IInventoryAlertDo
	Limit(limit int) IInventoryAlertDo
	Offset(offset int) IInventoryAlertDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IInventoryAlertDo
	Unscoped() IInventoryAlertDo
	Create(values ...*model.InventoryAlert) error
	CreateInBatches(values []*model.InventoryAlert, batchSize int) error
	Save(values ...*model.InventoryAlert) error
	First() (*model.InventoryAlert, error)
	Take() (*model.InventoryAlert, error)
	Last() (*model.InventoryAlert, error)
	Find() ([]*model.InventoryAlert, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.InventoryAlert, err error)
	FindInBatches(result *[]*model.InventoryAlert, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.InventoryAlert) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IInventoryAlertDo
	Assign(attrs ...field.AssignExpr) IInventoryAlertDo
	Joins(fields ...field.RelationField) IInventoryAlertDo
	Preload(fields ...field.RelationField) IInventoryAlertDo
	FirstOrInit() (*model.InventoryAlert, error)
	FirstOrCreate() (*model.InventoryAlert, error)
	FindByPage(offset int, limit int) (result []*model.InventoryAlert, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IInventoryAlertDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (i inventoryAlertDo) Debug() IInventoryAlertDo {
	return i.withDO(i.DO.Debug())
}

func (i inventoryAlertDo) WithContext(ctx context.Context) IInventoryAlertDo {
	return i.withDO(i.DO.WithContext(ctx))
}

func (i inventoryAlertDo) ReadDB() IInventoryAlertDo {
	return i.Clauses(dbresolver.Read)
}

func (i inventoryAlertDo) WriteDB() IInventoryAlertDo {
	return i.Clauses(dbresolver.Write)
}

func (i inventoryAlertDo) Session(config *gorm.Session) IInventoryAlertDo {
	return i.withDO(i.DO.Session(config))
}

func (i inventoryAlertDo) Clauses(conds ...clause.Expression) IInventoryAlertDo {
	return i.withDO(i.DO.Clauses(conds...))
}

func (i inventoryAlertDo) Returning(value interface{}, columns ...string) IInventoryAlertDo {
	return i.withDO(i.DO.Returning(value, columns...))
}

func (i inventoryAlertDo) Not(conds ...gen.Condition) IInventoryAlertDo {
	return i.withDO(i.DO.Not(conds...))
}

func (i inventoryAlertDo) Or(conds ...gen.Condition) IInventoryAlertDo {
	return i.withDO(i.DO.Or(conds...))
}

func (i inventoryAlertDo) Select(conds ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Select(conds...))
}

func (i inventoryAlertDo) Where(conds ...gen.Condition) IInventoryAlertDo {
	return i.withDO(i.DO.Where(conds...))
}

func (i inventoryAlertDo) Order(conds ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Order(conds...))
}

func (i inventoryAlertDo) Distinct(cols ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Distinct(cols...))
}

func (i inventoryAlertDo) Omit(cols ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Omit(cols...))
}

func (i inventoryAlertDo) Join(table schema.Tabler, on ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Join(table, on...))
}

func (i inventoryAlertDo) LeftJoin(table schema.Tabler, on ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.LeftJoin(table, on...))
}

func (i inventoryAlertDo) RightJoin(table schema.Tabler, on ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.RightJoin(table, on...))
}

func (i inventoryAlertDo) Group(cols ...field.Expr) IInventoryAlertDo {
	return i.withDO(i.DO.Group(cols...))
}

func (i inventoryAlertDo) Having(conds ...gen.Condition) IInventoryAlertDo {
	return i.withDO(i.DO.Having(conds...))
}

func (i inventoryAlertDo) Limit(limit int) IInventoryAlertDo {
	return i.withDO(i.DO.Limit(limit))
}

func (i inventoryAlertDo) Offset(offset int) IInventoryAlertDo {
	return i.withDO(i.DO.Offset(offset))
}

func (i inventoryAlertDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IInventoryAlertDo {
	return i.withDO(i.DO.Scopes(funcs...))
}

func (i inventoryAlertDo) Unscoped() IInventoryAlertDo {
	return i.withDO(i.DO.Unscoped())
}

func (i inventoryAlertDo) Create(values ...*model.InventoryAlert) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Create(values)
}

func (i inventoryAlertDo) CreateInBatches(values []*model.InventoryAlert, batchSize int) error {
	return i.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (i inventoryAlertDo) Save(values ...*model.InventoryAlert) error {
	if len(values) == 0 {
		return nil
	}
	return i.DO.Save(values)
}

func (i inventoryAlertDo) First() (*model.InventoryAlert, error) {
	if result, err := i.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.InventoryAlert), nil
	}
}

func (i inventoryAlertDo) Take() (*model.InventoryAlert, error) {
	if result, err := i.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.InventoryAlert), nil
	}
}

func (i inventoryAlertDo) Last() (*model.InventoryAlert, error) {
	if result, err := i.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.InventoryAlert), nil
	}
}

func (i inventoryAlertDo) Find() ([]*model.InventoryAlert, error) {
	result, err := i.DO.Find()
	return result.([]*model.InventoryAlert), err
}

func (i inventoryAlertDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.InventoryAlert, err error) {
	buf := make([]*model.InventoryAlert, 0, batchSize)
	err = i.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (i inventoryAlertDo) FindInBatches(result *[]*model.InventoryAlert, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return i.DO.FindInBatches(result, batchSize, fc)
}

func (i inventoryAlertDo) Attrs(attrs ...field.AssignExpr) IInventoryAlertDo {
	return i.withDO(i.DO.Attrs(attrs...))
}

func (i inventoryAlertDo) Assign(attrs ...field.AssignExpr) IInventoryAlertDo {
	return i.withDO(i.DO.Assign(attrs...))
}

func (i inventoryAlertDo) Joins(fields ...field.RelationField) IInventoryAlertDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Joins(_f))
	}
	return &i
}

func (i inventoryAlertDo) Preload(fields ...field.RelationField) IInventoryAlertDo {
	for _, _f := range fields {
		i = *i.withDO(i.DO.Preload(_f))
	}
	return &i
}

func (i inventoryAlertDo) FirstOrInit() (*model.InventoryAlert, error) {
	if result, err := i.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.InventoryAlert), nil
	}
}

func (i inventoryAlertDo) FirstOrCreate() (*model.InventoryAlert, error) {
	if result, err := i.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.InventoryAlert), nil
	}
}

func (i inventoryAlertDo) FindByPage(offset int, limit int) (result []*model.InventoryAlert, count int64, err error) {
	result, err = i.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = i.Offset(-1).Limit(-1).Count()
	return
}

func (i inventoryAlertDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = i.Count()
	if err != nil {
		return
	}

	err = i.Offset(offset).Limit(limit).Scan(result)
	return
}

func (i inventoryAlertDo) Scan(result interface{}) (err error) {
	return i.DO.Scan(result)
}

func (i inventoryAlertDo) Delete(models ...*model.InventoryAlert) (result gen.ResultInfo, err error) {
	return i.DO.Delete(models)
}

func (i *inventoryAlertDo) withDO(do gen.Dao) *inventoryAlertDo {
	i.DO = *do.(*gen.DO)
	return i
}
